{"nodes":[{"pos":[11,41],"content":"PowerShell Engine Enhancements","needQuote":true,"nodes":[{"content":"PowerShell Engine Enhancements","pos":[0,30]}]},{"content":"PowerShell Engine Enhancements","pos":[65,95]},{"content":"The following improvements to the core PowerShell engine have been implemented for PowerShell 5.1:","pos":[99,197]},{"content":"Performance","pos":[203,214]},{"content":"Performance has improved in some important areas:","pos":[219,268]},{"content":"Startup","pos":[273,280]},{"content":"Pipelining to cmdlets like ForEach-Object and Where-Object is approximately 50% faster","pos":[284,370]},{"content":"Some example improvements (resuls may vary depending your your hardware):","pos":[373,446]},{"content":"Scenario","pos":[451,459]},{"content":"5.0 Time (ms)","pos":[462,475]},{"content":"5.1 Time (ms)","pos":[478,491]},{"content":"900","pos":[582,585]},{"content":"250","pos":[588,591]},{"pos":[596,622],"content":"First ever PowerShell run:"},{"content":"30000","pos":[665,670]},{"content":"13000","pos":[673,678]},{"pos":[683,712],"content":"Command analysis cache built:"},{"content":"7000","pos":[755,759]},{"content":"520","pos":[762,765]},{"content":"1400","pos":[809,813]},{"content":"750","pos":[816,819]},{"content":"One change related to startup may impact some (unsupported) scenarios.","pos":[825,895]},{"content":"PowerShell no longer reads the files <ph id=\"ph1\">`$pshome\\*.ps1xml`</ph> - these files have been converted to C# to avoid some file and cpu overhead of processing the xml files.","pos":[896,1056],"source":" PowerShell no longer\nreads the files `$pshome\\*.ps1xml` - these files have been converted to C# to avoid some file\nand cpu overhead of processing the xml files."},{"content":"The files still exist to support V2 side-by-side, so if you change the file contents, it will not have any effect to V5, only V2.","pos":[1057,1186],"source":" The files still exist to support V2 side-by-side,\nso if you change the file contents, it will not have any effect to V5, only V2."},{"content":"Note that changing the contents of these files was never a supported scenario.","pos":[1187,1265],"source":" Note that changing\nthe contents of these files was never a supported scenario."},{"content":"Another visible change is how PowerShell caches the exported commands and other information for modules that are installed on a system.","pos":[1267,1402],"source":"Another visible change is how PowerShell caches the exported commands and other information for\nmodules that are installed on a system."},{"content":"Previous, this cache was stored in the directory <ph id=\"ph1\">`$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\CommandAnalysis`</ph>.","pos":[1403,1517],"source":" Previous, this cache was stored in the directory\n`$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\CommandAnalysis`."},{"content":"In WMF 5.1, the cache is a single file <ph id=\"ph1\">`$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\ModuleAnalysisCache`</ph>.","pos":[1518,1626],"source":" In WMF 5.1, the cache is a single\nfile `$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\ModuleAnalysisCache`."},{"content":"See <bpt id=\"p1\">[</bpt>analysis_cache.md<ept id=\"p1\">]()</ept> for more details.","pos":[1627,1670],"source":"\nSee [analysis_cache.md]() for more details."},{"content":"Starting with version 5.1, PowerShell is available in different editions which denote varying feature sets and platform compatibility.","pos":[1672,1806]},{"content":"Bug Fixes","pos":[1813,1822]},{"content":"The following notable bugs were fixed:","pos":[1827,1865]},{"pos":[1871,1905],"content":"Module auto-discovery fully honors"},{"content":"Module auto-discovery (loading modules automatically without an explicit Import-Module when calling a command) was introduced in WMF3.","pos":[1931,2065],"source":"Module auto-discovery (loading modules automatically without an explicit Import-Module when calling a command)\nwas introduced in WMF3."},{"content":"When introduced, PowerShell checked for commands in <ph id=\"ph1\">`$PSHome\\Modules`</ph> before using <ph id=\"ph2\">`$env:PSModulePath`</ph>.","pos":[2066,2169],"source":" When introduced, PowerShell checked for commands in `$PSHome\\Modules` before\nusing `$env:PSModulePath`."},{"content":"WMF5.1 changes this behavior to honor <ph id=\"ph1\">`$env:PSModulePath`</ph> completely.","pos":[2171,2240],"source":"WMF5.1 changes this behavior to honor `$env:PSModulePath` completely."},{"content":"This allows for a user-authored module that defines commands provided by PowerShell (e.g. <ph id=\"ph1\">`Get-ChildItem`</ph>) to be auto-loaded and correctly overriding the built-in command.","pos":[2241,2413],"source":" This allows for a user-authored module \nthat defines commands provided by PowerShell (e.g. `Get-ChildItem`) to be auto-loaded and correctly overriding\nthe built-in command."},{"pos":[2419,2456],"content":"File redirection no longer hard-codes"},{"pos":[2482,2684],"content":"In all previous versions of PowerShell, it was impossible to control the file encoding used by the file redirection operator, e.g. <ph id=\"ph1\">`get-childitem &gt; out.txt`</ph> because PowerShell added <ph id=\"ph2\">`-Encoding Unicode`</ph>.","source":"In all previous versions of PowerShell, it was impossible to control the file encoding used by the file\nredirection operator, e.g. `get-childitem > out.txt` because PowerShell added `-Encoding Unicode`."},{"pos":[2686,2805],"content":"Starting with WMF 5.1, you can now change the file encoding of redirection by setting <ph id=\"ph1\">`$PSDefaultParameterValues`</ph>, e.g.","source":"Starting with WMF 5.1, you can now change the file encoding of redirection by setting `$PSDefaultParameterValues`, e.g."},{"pos":[2877,2919],"content":"Fixed a regression in accessing members of"},{"content":"A regression introduced in WMF5 broke accessing members of <ph id=\"ph1\">`System.Reflection.RuntimeType`</ph>, e.g. <ph id=\"ph2\">`[int].ImplementedInterfaces`</ph>.","pos":[2954,3081],"source":"A regression introduced in WMF5 broke accessing members of `System.Reflection.RuntimeType`, e.g. `[int].ImplementedInterfaces`."},{"content":"This bug has been fixed in WMF5.1.","pos":[3082,3116],"source":"\nThis bug has been fixed in WMF5.1."},{"content":"Fixed some issues with COM objects","pos":[3123,3157]},{"content":"WMF5 introduced a new COM binder for invoking methods on COM objects and accessing properties of COM objects.","pos":[3163,3272]},{"content":"This new binder improved performance significantly but also introduced some bugs which have been fixed in WMF5.1.","pos":[3273,3386],"source":"\nThis new binder improved performance significantly but also introduced some bugs which have been fixed in WMF5.1."},{"content":"Argument conversions were not always performed correctly","pos":[3393,3449]},{"content":"In the following example:","pos":[3456,3481]},{"pos":[3554,3852],"content":"The SendKeys method expects a string, but PowerShell did not convert the char to a string, deferring the conversion to IDispatch::Invoke, which uses VariantChangeType to do the conversion, which in this example resulted in sending the keys '1', '7', and '3' instead of the expected Volume.Mute key.","source":"The SendKeys method expects a string, but PowerShell did not convert the char to a string, deferring the conversion\nto IDispatch::Invoke, which uses VariantChangeType to do the conversion, which in this example resulted in sending\nthe keys '1', '7', and '3' instead of the expected Volume.Mute key."},{"content":"Enumerable COM objects not always handled correctly","pos":[3859,3910]},{"content":"PowerShell normally enumerates most enumerable objects, but a regression introduced in WMF5 prevented the enumeration of COM objects that implement IEnumerable.","pos":[3917,4077],"source":"PowerShell normally enumerates most enumerable objects, but a regression introduced in WMF5 prevented the enumeration\nof COM objects that implement IEnumerable."},{"content":"For example:","pos":[4079,4091]},{"pos":[4261,4390],"content":"In the above example, WMF5 incorrectly wrote the Scripting.Dictionary to the pipeline instead of enumerating the key value pairs.","source":"In the above example, WMF5 incorrectly wrote the Scripting.Dictionary to the pipeline\ninstead of enumerating the key value pairs."},{"pos":[4409,4439],"content":"was not allowed inside classes"},{"content":"WMF5 introduced classes with validation of type literals used in classes.","pos":[4445,4518]},{"content":"looks like a type literal but is not a true .Net type.","pos":[4532,4586],"source":" looks like a type\nliteral but is not a true .Net type."},{"content":"WMF5 incorrectly reported an error on <ph id=\"ph1\">`[ordered]`</ph> inside a class:","pos":[4588,4653],"source":"  WMF5 incorrectly reported an error on `[ordered]` inside a class:"},{"content":"Help on about topics with multiple versions does not work","pos":[4752,4809]},{"pos":[4815,5033],"content":"Before WMF5.1, if you had multiple versions of a module installed and they all shared a help topic, e.g. about_PSReadline, <ph id=\"ph1\">`help about_PSReadline`</ph> would return multiple topics with no obvious way to view the real help.","source":"Before WMF5.1, if you had multiple versions of a module installed and they all shared a help topic,\ne.g. about_PSReadline, `help about_PSReadline` would return multiple topics with no obvious way\nto view the real help."},{"content":"WMF5.1 fixes this by returning the help for the latest version of the topic.","pos":[5035,5111]},{"pos":[5113,5309],"content":"Get-Help does not provide a way to specify which version you want help for, the workaround is to navigate to the modules directory and view the help directly with a tool like your favorite editor.","source":"Get-Help does not provide a way to specify which version you want help for, the workaround is to\nnavigate to the modules directory and view the help directly with a tool like your favorite editor."}],"content":"---\ntitle: PowerShell Engine Enhancements\nauthor: jasonsh\n---\n\n# PowerShell Engine Enhancements #\n\nThe following improvements to the core PowerShell engine have been implemented for PowerShell 5.1:\n\n\n## Performance ##\n\nPerformance has improved in some important areas:\n\n1. Startup\n2. Pipelining to cmdlets like ForEach-Object and Where-Object is approximately 50% faster \n\nSome example improvements (resuls may vary depending your your hardware): \n\n| Scenario | 5.0 Time (ms) | 5.1 Time (ms) |\n| -------- | :---------------: | :---------------: |\n| `powershell -command \"echo 1\"` | 900 | 250 |\n| First ever PowerShell run: `powershell -command \"Unknown-Command\"` | 30000 | 13000 |\n| Command analysis cache built: `powershell -command \"Unknown-Command\"` | 7000 | 520 |\n| <code>1..1000000 &#124; % { }</code> | 1400 | 750 |\n  \nOne change related to startup may impact some (unsupported) scenarios. PowerShell no longer\nreads the files `$pshome\\*.ps1xml` - these files have been converted to C# to avoid some file\nand cpu overhead of processing the xml files. The files still exist to support V2 side-by-side,\nso if you change the file contents, it will not have any effect to V5, only V2. Note that changing\nthe contents of these files was never a supported scenario.\n\nAnother visible change is how PowerShell caches the exported commands and other information for\nmodules that are installed on a system. Previous, this cache was stored in the directory\n`$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\CommandAnalysis`. In WMF 5.1, the cache is a single\nfile `$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\ModuleAnalysisCache`.\nSee [analysis_cache.md]() for more details.\n\nStarting with version 5.1, PowerShell is available in different editions which denote varying feature sets and platform compatibility.\n\n\n\n## Bug Fixes ##\n\nThe following notable bugs were fixed:\n\n### Module auto-discovery fully honors `$env:PSModulePath` ###\n\nModule auto-discovery (loading modules automatically without an explicit Import-Module when calling a command)\nwas introduced in WMF3. When introduced, PowerShell checked for commands in `$PSHome\\Modules` before\nusing `$env:PSModulePath`.\n\nWMF5.1 changes this behavior to honor `$env:PSModulePath` completely. This allows for a user-authored module \nthat defines commands provided by PowerShell (e.g. `Get-ChildItem`) to be auto-loaded and correctly overriding\nthe built-in command.\n\n### File redirection no longer hard-codes `-Encoding Unicode` ###\n\nIn all previous versions of PowerShell, it was impossible to control the file encoding used by the file\nredirection operator, e.g. `get-childitem > out.txt` because PowerShell added `-Encoding Unicode`.\n\nStarting with WMF 5.1, you can now change the file encoding of redirection by setting `$PSDefaultParameterValues`, e.g.\n\n```\n$PSDefaultParameterValues[\"Out-File:Encoding\"] = \"Ascii\"\n```\n\n### Fixed a regression in accessing members of `System.Reflection.TypeInfo` ###\n\nA regression introduced in WMF5 broke accessing members of `System.Reflection.RuntimeType`, e.g. `[int].ImplementedInterfaces`.\nThis bug has been fixed in WMF5.1.\n\n\n### Fixed some issues with COM objects ###\n\nWMF5 introduced a new COM binder for invoking methods on COM objects and accessing properties of COM objects.\nThis new binder improved performance significantly but also introduced some bugs which have been fixed in WMF5.1.\n\n#### Argument conversions were not always performed correctly ####\n\nIn the following example:\n\n```\n$obj = new-object -com wscript.shell\n$obj.SendKeys([char]173)\n```\n\nThe SendKeys method expects a string, but PowerShell did not convert the char to a string, deferring the conversion\nto IDispatch::Invoke, which uses VariantChangeType to do the conversion, which in this example resulted in sending\nthe keys '1', '7', and '3' instead of the expected Volume.Mute key.\n\n#### Enumerable COM objects not always handled correctly ####\n\nPowerShell normally enumerates most enumerable objects, but a regression introduced in WMF5 prevented the enumeration\nof COM objects that implement IEnumerable.  For example:\n\n```\nfunction Get-COMDictionary\n{\n    $d = New-Object -ComObject Scripting.Dictionary\n    $d.Add('a', 2)\n    $d.Add('b', 2)\n    return $d\n}\n\n$x = Get-COMDictionary\n```\n\nIn the above example, WMF5 incorrectly wrote the Scripting.Dictionary to the pipeline\ninstead of enumerating the key value pairs.\n\n\n### `[ordered]` was not allowed inside classes ###\n\nWMF5 introduced classes with validation of type literals used in classes.  `[ordered]` looks like a type\nliteral but is not a true .Net type.  WMF5 incorrectly reported an error on `[ordered]` inside a class:\n\n```\nclass CThing\n{\n    [object] foo($i)\n    {\n        [ordered]@{ Thing = $i }\n    }\n}\n```\n\n\n### Help on about topics with multiple versions does not work ###\n\nBefore WMF5.1, if you had multiple versions of a module installed and they all shared a help topic,\ne.g. about_PSReadline, `help about_PSReadline` would return multiple topics with no obvious way\nto view the real help.\n\nWMF5.1 fixes this by returning the help for the latest version of the topic.\n\nGet-Help does not provide a way to specify which version you want help for, the workaround is to\nnavigate to the modules directory and view the help directly with a tool like your favorite editor. \n"}