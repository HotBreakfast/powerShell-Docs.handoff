---
title: "Новые сценарии и возможности в WMF 5.1 (предварительная версия)"
ms.date: 2016-07-06
keywords: PowerShell, DSC, WMF
description: 
ms.topic: article
author: keithb
manager: dongill
ms.prod: powershell
ms.technology: WMF
translationtype: Human Translation
ms.sourcegitcommit: dcccf6880873c3f5c1b58fb1a8c546901b173879
ms.openlocfilehash: 9341b7fc3feea20cc2434065c3e512d1a8dd2b54

---

# Новые сценарии и возможности в WMF 5.1 (предварительная версия) #

> Примечание. Эта информация является предварительной и может быть изменена.

## Выпуски PowerShell ##
Начиная с версии 5.1 доступны различные выпуски среды PowerShell, что означает различные наборы возможностей и совместимость с разными платформами.

- **Выпуск Desktop Edition:** построен на основе .NET Framework и обеспечивает совместимость со скриптами и модулями, которые предназначены для версий PowerShell, выполняющихся в полноценных выпусках Windows, таких как Server Core и Windows Desktop.
- **Выпуск Core Edition:** построен на основе .NET Core и обеспечивает совместимость со скриптами и модулями, которые предназначены для версий PowerShell, выполняющихся в выпусках Windows с ограниченными возможностями, таких как Nano Server и Windows IoT.

**Дополнительные сведения об использовании выпусков PowerShell**
- [Определение запущенного выпуска PowerShell]()
- [Объявление совместимости модуля с определенными версиями PowerShell]()
- [Фильтрация результатов командлета Get-Module по CompatiblePSEditions]()
- [Запрет на выполнение скриптов в несовместимых выпусках PowerShell]()

## Кэш анализа модуля ##
Начиная с версии WMF 5.1 среда PowerShell предоставляет средства управления файлом, в котором кэшируются сведения о модуле, например экспортируемые им команды.

По умолчанию этот кэш хранится в файле `${env:LOCALAPPDATA}\Microsoft\Windows\PowerShell\ModuleAnalysisCache`.
Кэш обычно считывается при запуске в процессе поиска команды и записывается в фоновом потоке через некоторое время после импорта модуля.

Чтобы изменить расположение кэша по умолчанию, задайте переменную среды PSModuleAnalysisCachePath перед запуском PowerShell. Изменения, вносимые в эту переменную среды, влияют только на дочерние процессы.
Значение должно быть полным путем (включая имя файла), на создание и запись файлов по которому у среды PowerShell есть разрешение.
Чтобы отключить файловый кэш, укажите в качестве этого значения недопустимое расположение, например:

```PowerShell
$env:PSModuleAnalysisCachePath = 'nul'
```

Таким образом задается путь к недопустимому устройству. Если среда PowerShell не может осуществлять запись по указанному пути, ошибка не выводится, хотя в трассировщике может выводиться сообщение об ошибке:

```PowerShell
Trace-Command -PSHost -Name Modules -Expression { Import-Module Microsoft.PowerShell.Management -Force }
```

При выгрузке кэша среда PowerShell ищет модули, которые больше не существуют, чтобы кэш не был излишне большим.
Иногда эти проверки нежелательны. В этом случае их можно отключить, задав

```PowerShell
$env:PSDisableModuleAnalysisCacheCleanup = 1
```

Новое значение этой переменной среды вступает в силу немедленно в текущем процессе.

##Указание версии модуля

В WMF 5.1 `using module` работает так же, как другие связанные с модулями конструкции в PowerShell. Ранее не было возможности указать определенную версию модуля; при наличии нескольких версий возникала ошибка.


В WMF 5.1:

* Можно использовать [хэш-таблицу](https://msdn.microsoft.com/en-us/library/jj136290(v=vs.85).aspx) `ModuleSpecification`. Она имеет тот же формат, что и `Get-Module -FullyQualifiedName`.

**Пример:** `using module @{ModuleName = 'PSReadLine'; RequiredVersion = '1.1'}`

* Если имеется несколько версий модуля, в PowerShell используется **та же логика разрешения**, что и в `Import-Module`, и ошибка не выводится. Это поведение аналогично поведению `Import-Module` и `Import-DscResource`.

## Усовершенствования консоли PowerShell

Для улучшения работы с консолью в Powershell.exe в WMF 5.1 были внесены перечисленные ниже изменения.

###Поддержка VT100

В Windows 10 реализована поддержка [escape-последовательностей VT100](https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx).
При расчете ширины таблиц PowerShell игнорирует некоторые escape-последовательности форматирования VT100.

В PowerShell также появился новый интерфейс API, который можно использовать при форматировании кода для определения наличия поддержки VT100. Например:

```
if ($host.UI.SupportsVirtualTerminal)
{
    $esc = [char]0x1b
    "A yellow ${esc}[93mhello${esc}[0m"
}
else
{
    "A default hello"
}
```
Вот полный [пример](https://gist.github.com/lzybkr/dcb973dccd54900b67783c48083c28f7), который можно использовать для выделения совпадений в результатах выполнения командлета Select-String.
Сохраните пример в файле с именем `MatchInfo.format.ps1xml`. Чтобы использовать его, в своем профиле или другом месте выполните команду `Update-FormatData -Prepend MatchInfo.format.ps1xml`.

Имейте в виду, что escape-последовательности VT100 поддерживаются начиная с юбилейного обновления Windows 10. В более ранних системах они не поддерживаются.   

### Поддержка режима vi в PSReadline

В [PSReadline](https://github.com/lzybkr/PSReadLine) добавлена поддержка режима vi. Чтобы включить режим vi, выполните команду `Set-PSReadline -EditMode vi`.

### Перенаправленный поток stdin с интерактивным вводом 

В предыдущих версиях среду PowerShell требовалось запускать с помощью команды `powershell -File -`, если поток stdin перенаправлялся и необходимо было вводить команды в интерактивном режиме.

В WMF 5.1 этот труднодоступный параметр больше не нужен — PowerShell можно запускать без параметров: `powershell`.

Обратите внимание на то, что PSReadline в настоящее время не поддерживает перенаправленный поток stdin, а встроенные возможности редактирования в командной строке с перенаправленным потоком stdin крайне ограничены, например, не работают клавиши со стрелками.  В будущих версиях PSReadline эта проблема должна быть решена.   

##Усовершенствования подсистемы PowerShell

В WMF 5.1 были реализованы перечисленные ниже улучшения основной подсистемы PowerShell.


## Производительность ##

Производительность улучшена в некоторых важных аспектах:

- Запуск
- Передача данных по конвейеру в такие командлеты, как ForEach-Object и Where-Object, выполняется примерно на 50 % быстрее. 

Примеры некоторых улучшений (результаты могут различаться в зависимости от оборудования): 

| Сценарий | Время в версии 5.0 (мс) | Время в версии 5.1 (мс) |
| -------- | :---------------: | :---------------: |
| `powershell -command "echo 1"` | 900 | 250 |
| Самый первый запуск PowerShell: `powershell -command "Unknown-Command"` | 30 000 | 13 000 |
| Построение кэша анализа команд: `powershell -command "Unknown-Command"` | 7000 | 520 |
| `1..1000000 | % { }` | 1400 | 750 |
  
> [!NOTE]  
> Одно из изменений, связанных с запуском, может повлиять на некоторые неподдерживаемые сценарии. PowerShell больше не считывает файлы `$pshome\*.ps1xml` — эти файлы были преобразованы в C# во избежание накладных расходов, связанных с обработкой XML-файлов. Эти файлы по-прежнему существуют для поддержки параллельно установленной версии 2, поэтому изменение их содержимого сказывается только на версии 2, но не на версии 5. Обратите внимание на то, что изменение содержимого этих файлов никогда не поддерживалось.

Еще одним явным изменением является то, как PowerShell кэширует экспортируемые команды и другую информацию для модулей, установленных в системе. Ранее этот кэш хранился в каталоге `$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`. В WMF 5.1 этот кэш является отдельным файлом `$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`.
Подробные сведения см. в разделе, посвященном файлу [analysis_cache.md]().



## Устранение ошибок ##

Исправлены перечисленные ниже важные ошибки.

### При автоматическом обнаружении модулей полностью учитывается `$env:PSModulePath` ###

Автоматическое обнаружение модулей (их автоматическая загрузка без явного вызова Import-Module при вызове команды) появилось в WMF 3. В этой версии среда PowerShell проверяла команды в `$PSHome\Modules` перед использованием `$env:PSModulePath`.

В WMF 5.1 это поведение изменилось: `$env:PSModulePath` учитывается полностью. Это позволяет автоматически загружать созданные пользователями модули, в которых определяются предоставляемые PowerShell команды (например, `Get-ChildItem`), и правильно переопределять встроенные команды.

### При перенаправлении файлов больше не задается жестко `-Encoding Unicode` ###

Во всех предыдущих версиях PowerShell было невозможно контролировать кодировку файлов, используемую оператором перенаправления файлов, например `get-childitem > out.txt`, так как среда PowerShell добавляла параметр `-Encoding Unicode`.

Начиная с версии WMF 5.1 можно изменять кодировку файлов при перенаправлении, задавая `$PSDefaultParameterValues`, например:

```
$PSDefaultParameterValues["Out-File:Encoding"] = "Ascii"
```

### Исправлена регрессия при доступе к членам `System.Reflection.TypeInfo` ###

Появившаяся в WMF 5.0 регрессия нарушала доступ к членам `System.Reflection.RuntimeType`, например `[int].ImplementedInterfaces`.
Эта ошибка исправлена в WMF 5.1.


### Исправлены некоторые проблемы с COM-объектами ###

В WMF 5.0 появился новый модуль привязки COM для вызова методов применительно к COM-объектам и доступа к свойствам COM-объектов.
Этот новый модуль значительно повысил производительность, но в нем был ряд ошибок, которые исправлены в WMF 5.1.

#### Преобразование аргументов не всегда выполнялось правильно ####

Рассмотрим следующий пример:

```
$obj = new-object -com wscript.shell
$obj.SendKeys([char]173)
```

Метод SendKeys требует строку, но среда PowerShell не преобразовала char в string, отложив преобразование до вызова метода IDispatch::Invoke, который использует VariantChangeType для выполнения преобразования. В этом примере это приводит к отправке ключей "1", "7" и "3" вместо требуемого ключа Volume.Mute.

#### Перечисляемые COM-объекты не всегда обрабатывались правильно ####

Среда PowerShell, как правило, перечисляет большинство перечисляемых объектов, но регрессия, появившаяся в WMF 5.0, препятствовала перечислению COM-объектов, реализующих интерфейс IEnumerable.  Например:

```
function Get-COMDictionary
{
    $d = New-Object -ComObject Scripting.Dictionary
    $d.Add('a', 2)
    $d.Add('b', 2)
    return $d
}

$x = Get-COMDictionary
```

В приведенном выше примере WMF 5.0 неправильно записывает Scripting.Dictionary в конвейер вместо перечисления пар "ключ-значение".


### `[ordered]` не разрешалось использовать в классах ###

В WMF 5 появились классы, в которых проверялось использование литералов типов.  `[ordered]` выглядит как литерал типа, но в действительности не является типом .Net.  В WMF 5 неправильно выдавалась ошибка для `[ordered]` внутри класса:

```
class CThing
{
    [object] foo($i)
    {
        [ordered]@{ Thing = $i }
    }
}
```


### Вызов разделов справки при наличии нескольких версий не работал ###

До версии WMF 5.1 при наличии нескольких установленных версий модуля с общим разделом справки, например "about_PSReadline", команда `help about_PSReadline` возвращала несколько разделов без возможности просмотреть саму справку.

В WMF 5.1 эта проблема устранена: теперь возвращается последняя версия раздела.

Командлет Get-Help не позволяет указать версию, по которой требуется справка. В качестве обходного решения можно перейти к каталогу модулей и открыть справку напрямую, например с помощью любимого редактора. 

## Усовершенствования модуля OneGet
В WMF 5.1 внесен ряд исправлений и улучшений с целью устранить некоторые проблемы, возникавшие у пользователей при работе с версией WMF 5.0. 

###Удаление псевдонима Version

**Сценарий**. Если в системе установлены версии 1.0 и 2.0 пакета P1 и вы хотите удалить версию 1.0, то вы выполняете команду "uninstall-package -name P1 -version 1.0". При этом вы ожидаете, что после выполнения командлета будет удалена версия 1.0. Но в результате удаляется версия 2.0. 
    
Это происходит потому, что параметр -version является псевдонимом параметра -minimumversion. Когда модуль OneGet ищет подходящий пакет с минимальной версией 1.0, он возвращает последнюю версию. Такое поведение является нормальным в большинстве случаев, так как обычно требуется найти именно последнюю версию. Но в случае с удалением пакета ситуация иная.
    
**Решение**. В WMF 5.1 псевдоним -version полностью удален из модулей OneGet и PowerShellGet. 

###Несколько запросов на начальную загрузку поставщика NuGet

**Сценарий**. При первом выполнении командлета Find-Module, Install-Module или других командлетов OneGet на компьютере модуль OneGet пытается выполнить начальную загрузку поставщика NuGet. Связано это с тем, что поставщик PowershellGet также использует поставщик NuGet для скачивания модулей PowerShell. Затем модуль OneGet запрашивает у пользователя разрешение на установку поставщика NuGet. После того как пользователь разрешает начальную загрузку, устанавливается последняя версия поставщика NuGet. 
    
Но если на компьютере установлена старая версия поставщика NuGet, она иногда может загружаться первой в сеанс PowerShell (так как в OneGet возникает состояние гонки). Но модуль PowerShellGet требует, чтобы работала последняя версия поставщика NuGet, поэтому он еще раз запрашивает начальную загрузку поставщика NuGet у модуля OneGet. Это приводит к выводу нескольких запросов на начальную загрузку поставщика NuGet.

**Решение**. В WMF 5.1 модуль OneGet теперь загружает последнюю версию поставщика NuGet во избежание вывода нескольких запросов на начальную загрузку поставщика NuGet.

Также имеется обходной путь: вы можете вручную удалить старую версию поставщика NuGet (NuGet-Anycpu.exe), если она существует, из папок $env:ProgramFiles\PackageManagement\ProviderAssemblies и $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies


###Поддержка OneGet на компьютерах с доступом только к интрасети

**Сценарий**. В WMF 5.0 модуль OneGet не поддерживался на компьютерах с доступом только к интрасети (но не к Интернету).

**Решение**. Чтобы обеспечить использование OneGet на компьютерах в интрасети, в WMF 5.1 можно выполнить указанные ниже действия.

1. Скачайте поставщик NuGet с помощью другого компьютера, имеющего подключение к Интернету, выполнив команду "Install-PackageProvider NuGet".

2. Поставщик NuGet находится в папке $env:ProgramFiles\PackageManagement\ProviderAssemblies\nuget или $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies\nuget. 

3. Скопируйте двоичные файлы в папку или сетевую папку, к которой есть доступ у компьютера в интрасети, и установите поставщик NuGet, выполнив команду "Install-PackageProvider NuGet -Source <Path to folder>".


###Усовершенствования, касающиеся ведения журнала событий

При установке пакетов состояние компьютера меняется. В WMF 5.1 модуль OneGet теперь записывает в журнал событий Windows события, связанные с установкой, удалением и сохранением пакетов. Канал событий тот же, что и для PowerShell, то есть Microsoft-Windows-PowerShell, Operational.

###Поддержка обычной проверки подлинности

В WMF 5.1 модуль OneGet поддерживает поиск и установку пакетов из репозитория, требующего обычной проверки подлинности. Вы можете указывать учетные данные для командлетов Find-Package и Install-Package. Например:

``` PowerShell
Find-Package -Source <SourceWithCredential> -Credential (Get-Credential)
```
###Поддержка использования OneGet за прокси-сервером

В WMF 5.1 модуль OneGet теперь принимает новые параметры прокси-сервера: -ProxyCredential и -Proxy. С помощью этих параметров можно указать URL-адрес и учетные данные прокси-сервера для командлетов OneGet. По умолчанию используются системные настройки прокси-сервера. Например:

``` PowerShell
Find-Package -Source http://www.nuget.org/api/v2/ -Proxy http://www.myproxyserver.com -ProxyCredential (Get-Credential)
```



<!--HONumber=Jul16_HO1-->


